<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DaisyQuest World Map</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
        }
        #sidebar {
            width: 300px;
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            overflow-y: auto;
        }
        #main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #worldMapContainer {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #34495e;
            position: relative;
        }
        #worldMapCanvas {
            border: 2px solid #2c3e50;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #coordinates {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(44, 62, 80, 0.7);
            color: #ecf0f1;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        .player-info {
            background-color: #34495e;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .player-info h3 {
            margin-top: 0;
            color: #3498db;
        }
        #chat-box {
            height: 200px;
            background-color: #34495e;
            border-radius: 5px;
            padding: 10px;
            overflow-y: auto;
            margin-top: 20px;
        }
        #chat-input {
            width: 100%;
            margin-top: 10px;
        }

        /* New styles for combat interface */
        #combatArea {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        #turnIndicator {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            color: #f39c12;
        }
        #combatInfo {
            background-color: #34495e;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .player-card {
            background-color: #34495e;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
        }
        .player-sprite {
            position: relative;
            width: 128px;
            height: 128px;
            margin: 0 auto;
        }

        .sprite-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .health-bar {
            height: 20px;
            background-color: #e74c3c;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        .health-bar-fill {
            height: 100%;
            background-color: #2ecc71;
            transition: width 0.3s ease-in-out;
        }
        #actionButtons button {
            margin-bottom: 10px;
        }
        #spellSelection, #targetSelection {
            background-color: #34495e;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
        }
        #spellInfo {
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        .combat-log {
            height: 300px;
            background-color: #34495e;
            border-radius: 5px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.9em;
        }
        .combat-log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }
        #combatResults {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <div id="sidebar" class="col-md-3 bg-light">
            <h2 class="mb-4">DaisyQuest</h2>
            <div class="player-info">
                <h3>Player Info</h3>
                <p>Name: <span id="player-name"></span></p>
                <p>Level: <span id="player-level"></span></p>
                <p>Experience: <span id="player-exp"></span></p>
            </div>
            <div class="player-info">
                <h3>Nearby Players</h3>
                <ul id="nearby-players"></ul>
            </div>
            <div id="chat-box"></div>
            <input type="text" id="chat-input" class="form-control" placeholder="Type your message...">
        </div>
        <div class="col-md-9">
            <div id="worldMapContainer">
                <canvas id="worldMapCanvas"></canvas>
                <div id="coordinates"></div>
            </div>
            <div id="combatArea" style="display: none;">
                <div class="turn-indicator" id="turnIndicator"></div>
                <div id="combatInfo" class="mb-3"></div>
                <div class="row" id="playerCards"></div>
                <div class="row mt-4">
                    <div class="col-md-6">
                        <div id="actionButtons" class="d-flex justify-content-around">
                            <button class="btn btn-primary action-button" onclick="performAction('ATTACK')">Attack</button>
                            <button class="btn btn-primary action-button" onclick="performAction('SPECIAL_ATTACK')">Special Attack</button>
                            <button class="btn btn-primary action-button" onclick="performAction('SPELL')">Spell</button>
                            <button class="btn btn-primary action-button" onclick="performAction('TACTICS')">Tactics</button>
                        </div>
                        <div id="spellSelection" class="mt-3" style="display: none;">
                            <select id="spellSelect" class="form-select mb-2" onchange="handleSpellSelection()"></select>
                            <div id="spellInfo" class="card">
                                <div class="card-body">
                                    <h5 class="card-title" id="spellInfoName"></h5>
                                    <p class="card-text" id="spellInfoDescription"></p>
                                    <ul class="list-group list-group-flush">
                                        <li class="list-group-item" id="spellInfoManaCost"></li>
                                        <li class="list-group-item" id="spellInfoCooldown"></li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div id="targetSelection" class="mt-3" style="display: none;">
                            <select id="targetSelect" class="form-select mb-2"></select>
                            <button class="btn btn-primary w-100" onclick="confirmAction()">Confirm Action</button>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="combat-log" id="combatLog"></div>
                    </div>
                </div>
            </div>

            <div id="combatResults" style="display: none;">
                <h2>Combat Results</h2>
                <div id="resultsInfo"></div>
                <button class="btn btn-primary" onclick="returnToWorldMap()">Return to World Map</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<script>
    // World Map variables
    const canvas = document.getElementById('worldMapCanvas');
    const ctx = canvas.getContext('2d');
    const coordsDisplay = document.getElementById('coordinates');

    let worldMap;
    let players = [];
    let currentPlayer;
    const playerId = localStorage.getItem('playerId');
    if (!playerId) {
        window.location.href = '/login';
    }
    const LAND_SIZE = 10000;
    const VIEWPORT_WIDTH = 1000;
    const VIEWPORT_HEIGHT = 800;
    const SPRITE_SIZE = 32;

    const terrainColors = {
        PLAINS: '#90EE90',
        FOREST: '#228B22',
        MOUNTAIN: '#A0522D',
        WATER: '#4169E1',
        DESERT: '#F4A460'
    };

    // Combat variables
    let currentCombatId;
    let selectedAction;
    let selectedSpell;
    let playerSpells = [];
    let combatLogs = [];

    // Duel variables
    let selectedPlayer = null;
    const DUEL_RANGE = 100;
    let lastClickX, lastClickY;
    let socket;

    function initWorldMap() {
        fetch('/api/world-map')
            .then(response => response.json())
            .then(data => {
                worldMap = data;
                canvas.width = VIEWPORT_WIDTH;
                canvas.height = VIEWPORT_HEIGHT;
                return fetch(`/api/players/${playerId}`);
            })
            .then(response => response.json())
            .then(player => {
                currentPlayer = player;
                // Ensure the player has a valid position
                if (!currentPlayer.worldPositionX || !currentPlayer.worldPositionY) {
                    console.warn('Player position not set, using default position');
                    currentPlayer.worldPositionX = 10000; // Default X position
                    currentPlayer.worldPositionY = 10000; // Default Y position
                }
                console.log('Player position:', currentPlayer.worldPositionX, currentPlayer.worldPositionY);
                updatePlayerInfo();
                updatePlayerPosition(currentPlayer.worldPositionX, currentPlayer.worldPositionY);
                setupWebSocket();
                drawWorldMap();
            })
            .catch(error => {
                console.error('Error initializing world map:', error);
                // Handle the error, maybe set a default position or show an error message to the user
            });
    }
    async function drawWorldMap() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const startX = Math.floor(currentPlayer.worldPositionX / LAND_SIZE) * LAND_SIZE;
        const startY = Math.floor(currentPlayer.worldPositionY / LAND_SIZE) * LAND_SIZE;

        for (let y = -LAND_SIZE; y <= VIEWPORT_HEIGHT + LAND_SIZE; y += LAND_SIZE) {
            for (let x = -LAND_SIZE; x <= VIEWPORT_WIDTH + LAND_SIZE; x += LAND_SIZE) {
                const worldX = startX + x;
                const worldY = startY + y;

                const offsetX = Math.round(x - (currentPlayer.worldPositionX % LAND_SIZE) + VIEWPORT_WIDTH / 2);
                const offsetY = Math.round(y - (currentPlayer.worldPositionY % LAND_SIZE) + VIEWPORT_HEIGHT / 2);

                ctx.fillStyle = getTileColor(Math.floor(worldX / LAND_SIZE), Math.floor(worldY / LAND_SIZE));
                ctx.fillRect(offsetX, offsetY, LAND_SIZE, LAND_SIZE);

                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.strokeRect(offsetX, offsetY, LAND_SIZE, LAND_SIZE);
            }
        }

        for (const player of players) {
            if (player.id !== currentPlayer.id) {
                const x = Math.round(player.worldPositionX - currentPlayer.worldPositionX + VIEWPORT_WIDTH / 2);
                const y = Math.round(player.worldPositionY - currentPlayer.worldPositionY + VIEWPORT_HEIGHT / 2);

                if (x >= -SPRITE_SIZE/2 && x < VIEWPORT_WIDTH + SPRITE_SIZE/2 &&
                    y >= -SPRITE_SIZE/2 && y < VIEWPORT_HEIGHT + SPRITE_SIZE/2) {
                    await drawPlayer(x, y, player, false);
                }
            }
        }

        await drawPlayer(VIEWPORT_WIDTH / 2, VIEWPORT_HEIGHT / 2, currentPlayer, true);

        coordsDisplay.textContent = `X: ${currentPlayer.worldPositionX}, Y: ${currentPlayer.worldPositionY}`;
    }

    function getTileColor(x, y) {
        // In a real implementation, you would fetch the actual terrain type for these coordinates
        const terrainType = ['PLAINS', 'FOREST', 'MOUNTAIN', 'WATER', 'DESERT'][Math.floor(Math.random() * 5)];
        return terrainColors['PLAINS'];
    }

    async function drawPlayer(x, y, player, isCurrentPlayer) {
        const layers = [
            player.subspriteBackground || 'background_0',
            player.subspriteFace || 'face_0',
            player.subspriteEyes || 'eyes_0',
            player.subspriteHairHat || 'hairhat_0'
        ];

        try {
            for (const layer of layers) {
                const sprite = await loadSprite(layer);
                ctx.drawImage(sprite, x - SPRITE_SIZE / 2, y - SPRITE_SIZE / 2, SPRITE_SIZE, SPRITE_SIZE);
            }

            ctx.fillStyle = isCurrentPlayer ? '#e74c3c' : '#3498db';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(player.username, x, y + SPRITE_SIZE / 2 + 15);

            if (!isCurrentPlayer) {
                ctx.beginPath();
                ctx.arc(x, y, SPRITE_SIZE / 2, 0, 2 * Math.PI);
                if (ctx.isPointInPath(lastClickX, lastClickY)) {
                    handlePlayerClick(player);
                }
            }
        } catch (error) {
            console.error('Error loading sprite:', error);
            ctx.fillStyle = isCurrentPlayer ? '#e74c3c' : '#3498db';
            ctx.beginPath();
            ctx.arc(x, y, SPRITE_SIZE / 2, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    function loadSprite(spriteName) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = `/sprites/${spriteName}.png`;
        });
    }

    function updatePlayerInfo() {
        if (currentPlayer && currentPlayer.username)
            document.getElementById('player-name').textContent = currentPlayer.username;
        if (currentPlayer && currentPlayer.level) {
            document.getElementById('player-level').textContent = currentPlayer.level;
        }
        if (currentPlayer && currentPlayer.experience) {
            document.getElementById('player-exp').textContent = currentPlayer.experience;
        }
    }

    function updateNearbyPlayersList() {
        const nearbyPlayersList = document.getElementById('nearby-players');
        if (!nearbyPlayersList) {
            console.error('Failed to find the nearby players list element in the document.');
            return;
        }

        nearbyPlayersList.innerHTML = '';

        if (!Array.isArray(players)) {
            console.error('Players data is not an array or is undefined.');
            return;
        }

        players.forEach(player => {
            if (!player || typeof player !== 'object') {
                console.error('Invalid player data detected.', player);
                return;
            }

            if (!currentPlayer || !currentPlayer.id) {
                console.error('Current player data is missing or incomplete.');
                return;
            }

            if (player.id !== currentPlayer.id) {
                if (!player.username || typeof player.level === 'undefined') {
                    console.error('Player data is incomplete. Missing username or level.', player);
                    return;
                }

                const li = document.createElement('li');
                li.textContent = `${player.username} (Level ${player.level})`;
                nearbyPlayersList.appendChild(li);
            }
        });
    }

    const MOVE_SPEED = 32; // pixels per second
    const MOVE_INTERVAL = 1000 / 60; // 60 FPS
    const SEND_INTERVAL = 200; // Send position to server every 200ms

    let moveInterval;
    let sendInterval;
    let movementVector = { x: 0, y: 0 };
    let accumulatedMovement = { x: 0, y: 0 };

    function updatePlayerPosition(playerIdOfPlayerToUpdate, x, y) {
        // Prevent movement to 0,0 or negative coordinates
        if (x <= 0 || y <= 0) {
            console.log('Attempted move to invalid position:', x, y);
            return;
        }

        // Round the coordinates to prevent floating point issues
        x = Math.round(x);
        y = Math.round(y);

        if (playerIdOfPlayerToUpdate === currentPlayer.id) {
            // Update current player's position
            if (x === currentPlayer.worldPositionX && y === currentPlayer.worldPositionY) {
                console.log('Current player position unchanged, skipping update');
                return;
            }

            console.log('Updating current player position to:', x, y);

            fetch('/api/world-map/move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    playerId: currentPlayer.id,
                    newX: x,
                    newY: y
                })
            })
                .then(response => response.json())
                .then(updatedPlayer => {
                    if (updatedPlayer.worldPositionX !== currentPlayer.worldPositionX ||
                        updatedPlayer.worldPositionY !== currentPlayer.worldPositionY) {
                        currentPlayer.worldPositionX = updatedPlayer.worldPositionX;
                        currentPlayer.worldPositionY = updatedPlayer.worldPositionY;
                        updatePlayerInfo();
                        fetchPlayersInViewport();
                    }
                    drawWorldMap();
                })
                .catch(error => console.error('Error updating player position:', error));
        } else {
            // Update other player's position
            const player = players.find(p => p.id === playerIdOfPlayerToUpdate);
            if (player) {
                console.log('Updating other player position:', playerIdOfPlayerToUpdate, x, y);
                player.worldPositionX = x;
                player.worldPositionY = y;
                drawWorldMap();
            } else {
                console.log('Player not found in viewport:', playerIdOfPlayerToUpdate);
                fetchPlayersInViewport(); // Refresh the players in viewport
            }
        }
    }




    const sendPositionToServer = debounce(() => {
        updatePlayerPosition(playerId, currentPlayer.worldPositionX, currentPlayer.worldPositionY);
    }, SEND_INTERVAL);

    function updateLocalPosition() {
        if (movementVector.x !== 0 || movementVector.y !== 0) {
            const normalizedVector = normalizeVector(movementVector);
            accumulatedMovement.x += normalizedVector.x * (MOVE_SPEED * MOVE_INTERVAL / 1000);
            accumulatedMovement.y += normalizedVector.y * (MOVE_SPEED * MOVE_INTERVAL / 1000);

            // Only update position when accumulated movement is >= 1 pixel
            if (Math.abs(accumulatedMovement.x) >= 1) {
                currentPlayer.worldPositionX += Math.trunc(accumulatedMovement.x);
                accumulatedMovement.x = accumulatedMovement.x % 1;
            }
            if (Math.abs(accumulatedMovement.y) >= 1) {
                currentPlayer.worldPositionY += Math.trunc(accumulatedMovement.y);
                accumulatedMovement.y = accumulatedMovement.y % 1;
            }

            drawWorldMap();
        }
    }

    function normalizeVector(vector) {
        const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
        return magnitude !== 0 ? { x: vector.x / magnitude, y: vector.y / magnitude } : { x: 0, y: 0 };
    }

    // Event listeners for movement
    canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        lastClickX = event.clientX - rect.left;
        lastClickY = event.clientY - rect.top;

        const worldX = currentPlayer.worldPositionX + Math.round(lastClickX - VIEWPORT_WIDTH / 2);
        const worldY = currentPlayer.worldPositionY + Math.round(lastClickY - VIEWPORT_HEIGHT / 2);

        updatePlayerPosition(currentPlayer.id, worldX, worldY);
    });

    document.addEventListener('keydown', (event) => {
        switch (event.key.toLowerCase()) {
            case 'w': movementVector.y = -1; break;
            case 'a': movementVector.x = -1; break;
            case 's': movementVector.y = 1; break;
            case 'd': movementVector.x = 1; break;
        }
        if (!moveInterval) {
            moveInterval = setInterval(updateLocalPosition, MOVE_INTERVAL);
        }
        if (!sendInterval) {
            sendInterval = setInterval(sendPositionToServer, SEND_INTERVAL);
        }
    });

    document.addEventListener('keyup', (event) => {
        switch (event.key.toLowerCase()) {
            case 'w': case 's': movementVector.y = 0; break;
            case 'a': case 'd': movementVector.x = 0; break;
        }
        if (movementVector.x === 0 && movementVector.y === 0) {
            clearInterval(moveInterval);
            clearInterval(sendInterval);
            moveInterval = null;
            sendInterval = null;
            sendPositionToServer(); // Send final position
        }
    });

    // Debounce function
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }



    function fetchPlayersInViewport() {
        const centerX = currentPlayer.worldPositionX;
        const centerY = currentPlayer.worldPositionY;

        fetch(`/api/world-map/players?centerX=${centerX}&centerY=${centerY}&viewportWidth=${VIEWPORT_WIDTH}&viewportHeight=${VIEWPORT_HEIGHT}`)
            .then(response => response.json())
            .then(data => {
                players = data;
                updateNearbyPlayersList();
                drawWorldMap();
            });
    }



    function startCombat() {
        console.log('Starting combat');
        fetch('/api/combat/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ playerIds: [playerId, 'AI1', 'AI2'], playerTeams: {} })
        })
            .then(response => response.json())
            .then(combat => {
                console.log('Combat started:', combat);
                currentCombatId = combat.id;
                document.getElementById('worldMapContainer').style.display = 'none';
                document.getElementById('combatArea').style.display = 'block';
                updateCombatUI(combat);
                fetchPlayerSpells();
                pollCombatStatus();
            })
            .catch(error => console.error('Error starting combat:', error));
    }

    function fetchPlayerSpells() {
        fetch(`/api/players/${playerId}/spells`)
            .then(response => response.json())
            .then(spells => {
                playerSpells = spells;
                updateSpellSelection();
            })
            .catch(error => console.error('Error fetching player spells:', error));
    }

    function pollCombatStatus() {
        if (!currentCombatId) {
            console.log('No active combat to poll');
            return;
        }

        console.log('Polling combat status for:', currentCombatId);
        fetch(`/api/combat/${currentCombatId}`)
            .then(response => response.json())
            .then(combat => {
                console.log('Received combat update:', combat);
                if (combat.active) {
                    updateCombatUI(combat);
                    setTimeout(pollCombatStatus, 2000);
                } else {
                    console.log('Combat ended');
                    showCombatResults(combat);
                }
            })
            .catch(error => {
                console.error('Error polling combat status:', error);
                setTimeout(pollCombatStatus, 2000);
            });
    }

    function updateCombatUI(combat) {
        console.log('Updating combat UI:', combat);
        updatePlayerCards(combat);
        updateTurnIndicator(combat);
        updateCombatInfo(combat);
        updateSpellCooldowns(combat);
        updateActionButtons(combat);
        updateSelectionVisibility(combat);
        fetchAndUpdateCombatLog(combat.id);
    }

    function updatePlayerCards(combat) {
        const playerCardsContainer = document.getElementById('playerCards');
        playerCardsContainer.innerHTML = '';

        const playerCount = combat.playerIds.length;
        const spriteSize = playerCount < 5 ? 128 : 64;

        combat.playerIds.forEach(id => {
            const health = combat.playerHealth[id];
            const maxHealth = combat.playerHealthStarting[id];
            const healthPercentage = (health / maxHealth) * 100;

            const playerCard = document.createElement('div');
            playerCard.className = `col-md-${Math.floor(12 / playerCount)} player-card`;
            playerCard.innerHTML = `
            <div class="player-sprite" style="width: ${spriteSize}px; height: ${spriteSize}px;">
                ${getPlayerSprite(id, spriteSize)}
            </div>
            <h3 class="text-center mt-2">${id}</h3>
            <div class="health-bar">
                <div class="health-bar-fill" style="width: ${healthPercentage}%"></div>
            </div>
            <p class="text-center mt-2">HP: ${health} / ${maxHealth}</p>
            <p class="text-center">AP: ${combat.playerActionPoints[id]}</p>
        `;
            playerCardsContainer.appendChild(playerCard);
        });
    }

    function getPlayerSprite(playerId, size) {
        if (playerId && playerId.startsWith('AI')) {
            return `<div class="player-sprite" style="width:${size}px;height:${size}px;">
                    <img src="/sprites/enemy_skeleton.png" width="${size}" height="${size}">
                </div>`;
        } else {
            const player = players.find(p => p.id === playerId) || currentPlayer;
            return `
            <div class="player-sprite" style="width:${size}px;height:${size}px;">
                <img src="/sprites/${player.subspriteBackground || 'background_1'}.png" class="sprite-layer">
                <img src="/sprites/${player.subspriteFace || 'face_1'}.png" class="sprite-layer">
                <img src="/sprites/${player.subspriteEyes || 'eyes_1'}.png" class="sprite-layer">
                <img src="/sprites/${player.subspriteHairHat || 'hairhat_1'}.png" class="sprite-layer">
            </div>
        `;
        }
    }

    function updateTurnIndicator(combat) {
        const turnIndicator = document.getElementById('turnIndicator');
        turnIndicator.textContent = `Current Turn: ${combat.currentTurnPlayerId}`;
        turnIndicator.style.color = combat.currentTurnPlayerId === playerId ? '#4caf50' : '#e94560';
    }

    function updateCombatInfo(combat) {
        const combatInfo = document.getElementById('combatInfo');
        combatInfo.innerHTML = `
        <p>Combat ID: ${combat.id}</p>
        <p>Current Turn: ${combat.currentTurnPlayerId}</p>
        <p>Turn Number: ${combat.turnNumber}</p>
        <p>Is Active: ${combat.active}</p>
    `;
    }

    function updateSpellCooldowns(combat) {
        if (combat.spellCooldowns && combat.spellCooldowns[playerId]) {
            const cooldowns = combat.spellCooldowns[playerId];
            const cooldownInfo = Object.entries(cooldowns)
                .map(([spellId, cooldown]) => {
                    const spell = playerSpells.find(s => s.id === spellId);
                    return spell ? `${spell.name}: ${cooldown}` : null;
                })
                .filter(Boolean)
                .join(', ');

            document.getElementById('combatInfo').innerHTML += `
            <p>Spell Cooldowns: ${cooldownInfo}</p>
        `;
        }
    }

    function updateActionButtons(combat) {
        const isPlayerTurn = combat.currentTurnPlayerId === playerId;
        const actionButtons = document.querySelectorAll('.action-button');
        actionButtons.forEach(button => button.disabled = !isPlayerTurn);
        document.getElementById('actionButtons').style.display = isPlayerTurn ? 'block' : 'none';
    }


    function fetchAndUpdateCombatLog(combatId) {
        fetch(`/api/combat/${combatId}/logs`)
            .then(response => response.json())
            .then(logs => {
                combatLogs = logs;
                updateCombatLogDisplay();
            })
            .catch(error => console.error('Error fetching combat logs:', error));
    }

    function updateCombatLogDisplay() {
        const combatLogDiv = document.getElementById('combatLog');
        combatLogDiv.innerHTML = combatLogs.map(log => createCombatLogEntry(log)).join('');
        combatLogDiv.scrollTop = combatLogDiv.scrollHeight;
    }

    function createCombatLogEntry(log) {
        let color = log.actorId === playerId ? '#4caf50' :
            log.isNeutral ? '#ffd700' : '#e94560';
        return `
        <div class="combat-log-entry" style="color: ${color}; ${log.actorId === playerId ? 'font-weight: bold;' : ''}">
            [Turn ${log.turnNumber}] ${log.description}
        </div>
    `;
    }

    function performAction(actionType) {
        selectedAction = actionType;
        const spellSelection = document.getElementById('spellSelection');
        const targetSelection = document.getElementById('targetSelection');

        spellSelection.style.display = 'none';
        targetSelection.style.display = 'none';

        if (actionType === 'SPELL') {
            spellSelection.style.display = 'block';
            updateSpellSelection();
            updateSpellInfo();
        } else {
            updateTargetSelection();
            targetSelection.style.display = 'block';
        }
    }


    function handleSpellSelection() {
        const spellId = document.getElementById('spellSelect').value;
        selectedSpell = playerSpells.find(spell => spell.id === spellId);
        updateSpellInfo();

        // Keep spell selection visible
        document.getElementById('spellSelection').style.display = 'block';

        // Show target selection after spell is chosen
        updateTargetSelection();
        document.getElementById('targetSelection').style.display = 'block';
    }

    function updateSelectionVisibility(combat) {
        const isPlayerTurn = combat.currentTurnPlayerId === playerId;
        const spellSelection = document.getElementById('spellSelection');
        const targetSelection = document.getElementById('targetSelection');

        if (isPlayerTurn) {
            // If it's the player's turn, show action buttons
            document.getElementById('actionButtons').style.display = 'block';

            // If a spell is selected, show both spell and target selection
            if (selectedAction === 'SPELL' && selectedSpell) {
                spellSelection.style.display = 'block';
                targetSelection.style.display = 'block';
            } else if (selectedAction === 'SPELL') {
                // If SPELL is selected but no spell chosen yet, only show spell selection
                spellSelection.style.display = 'block';
                targetSelection.style.display = 'none';
            } else if (selectedAction) {
                // For other actions, hide spell selection and show target selection
                spellSelection.style.display = 'none';
                targetSelection.style.display = 'block';
            } else {
                // If no action is selected yet, hide both
                spellSelection.style.display = 'none';
                targetSelection.style.display = 'none';
            }
        } else {
            // If it's not the player's turn, hide everything
            document.getElementById('actionButtons').style.display = 'none';
            spellSelection.style.display = 'none';
            targetSelection.style.display = 'none';
        }
    }

    function updateSpellSelection() {
        const spellSelect = document.getElementById('spellSelect');
        spellSelect.innerHTML = '';
        playerSpells.forEach(spell => {
            const option = document.createElement('option');
            option.value = spell.id;
            option.textContent = spell.name;
            spellSelect.appendChild(option);
        });
        updateSpellInfo();
    }

    function updateSpellInfo() {
        const spellId = document.getElementById('spellSelect').value;
        selectedSpell = playerSpells.find(spell => spell.id === spellId);

        if (selectedSpell) {
            document.getElementById('spellInfoName').textContent = selectedSpell.name;
            document.getElementById('spellInfoDescription').textContent = selectedSpell.description;
            document.getElementById('spellInfoManaCost').textContent = `Mana Cost: ${selectedSpell.manaCost}`;
            document.getElementById('spellInfoCooldown').textContent = `Cooldown: ${selectedSpell.cooldown} turns`;
        }
    }

    function updateTargetSelection() {
        const targetSelect = document.getElementById('targetSelect');
        targetSelect.innerHTML = '';

        fetch(`/api/combat/${currentCombatId}`)
            .then(response => response.json())
            .then(combat => {
                combat.playerIds.forEach(id => {
                    if (id !== playerId && combat.playerHealth[id] > 0) {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = id;
                        targetSelect.appendChild(option);
                    }
                });
            })
            .catch(error => console.error('Error updating target selection:', error));
    }

    function confirmAction() {
        const targetPlayerId = document.getElementById('targetSelect').value;
        if (!targetPlayerId) {
            alert('Please select a target.');
            return;
        }

        let actionData = {
            playerId: playerId,
            type: selectedAction,
            targetPlayerId: targetPlayerId,
            actionPoints: 1
        };

        if (selectedAction === 'SPELL') {
            if (!selectedSpell) {
                alert('Please select a spell.');
                return;
            }
            actionData.spellId = selectedSpell.id;
        }

        fetch(`/api/combat/${currentCombatId}/action`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(actionData)
        })
            .then(response => response.json())
            .then(updatedCombat => {
                updateCombatUI(updatedCombat);
                document.getElementById('spellSelection').style.display = 'none';
                document.getElementById('targetSelection').style.display = 'none';
                if (!updatedCombat.active) {
                    showCombatResults(updatedCombat);
                }
            })
            .catch(error => console.error('Error performing action:', error));

        selectedSpell = null;
    }

    function showCombatResults(combat) {
        document.getElementById('combatArea').style.display = 'none';
        document.getElementById('combatResults').style.display = 'block';
        const resultsDiv = document.getElementById('combatResults');
        const winner = determineWinner(combat);
        const loser = Object.keys(combat.playerHealth).find(id => id !== winner);

        resultsDiv.innerHTML = `
        <h2>Combat Ended</h2>
        <p>Winner: ${winner}</p>
        <p>Final Health:</p>
        <ul>
            ${Object.entries(combat.playerHealth).map(([id, health]) => `<li>${id}: ${health}</li>`).join('')}
        </ul>
    `;

        if (winner === playerId) {
            fetch(`/api/players/${loser}/inventory`)
                .then(response => response.json())
                .then(inventory => {
                    if (inventory.length > 0) {
                        const randomItem = inventory[Math.floor(Math.random() * inventory.length)];
                        resultsDiv.innerHTML += `
                        <p>You won the duel and took ${randomItem.name} from ${loser}!</p>
                    `;
                        transferItem(randomItem.id, loser, winner);
                    } else {
                        resultsDiv.innerHTML += `
                        <p>You won the duel, but ${loser} had no items to take.</p>
                    `;
                    }
                })
                .catch(error => console.error('Error fetching loser inventory:', error));
        } else {
            resultsDiv.innerHTML += `
            <p>You lost the duel. The winner may have taken one of your items.</p>
        `;
        }

        resultsDiv.innerHTML += `
        <button onclick="returnToWorldMap()">Return to World Map</button>
    `;
    }

    function determineWinner(combat) {
        return Object.entries(combat.playerHealth)
            .find(([id, health]) => health > 0)[0];
    }

    function transferItem(itemId, fromPlayerId, toPlayerId) {
        fetch('/api/inventory/transfer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                itemId: itemId,
                fromPlayerId: fromPlayerId,
                toPlayerId: toPlayerId
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Item transferred successfully');
                } else {
                    console.error('Failed to transfer item:', data.message);
                }
            })
            .catch(error => console.error('Error transferring item:', error));
    }

    function returnToWorldMap() {
        document.getElementById('combatResults').style.display = 'none';
        document.getElementById('worldMapContainer').style.display = 'block';
        currentCombatId = null;
        selectedPlayer = null;
        hideDuelButton();
        drawWorldMap();
    }

    // Duel functions
    function handlePlayerClick(player) {
        selectedPlayer = player;
        const distance = Math.sqrt(
            Math.pow(player.worldPositionX - currentPlayer.worldPositionX, 2) +
            Math.pow(player.worldPositionY - currentPlayer.worldPositionY, 2)
        );

        if (distance <= DUEL_RANGE) {
            showDuelButton();
        } else {
            hideDuelButton();
        }
    }

    function showDuelButton() {
        const duelButton = document.getElementById('duelButton');
        if (!duelButton) {
            const button = document.createElement('button');
            button.id = 'duelButton';
            button.textContent = 'Challenge to Duel';
            button.className = 'btn btn-danger';
            button.style.position = 'absolute';
            button.style.top = '10px';
            button.style.right = '10px';
            button.onclick = sendDuelRequest;
            document.body.appendChild(button);
        } else {
            duelButton.style.display = 'block';
        }
    }

    function hideDuelButton() {
        const duelButton = document.getElementById('duelButton');
        if (duelButton) {
            duelButton.style.display = 'none';
        }
    }

    function sendDuelRequest() {
        if (!selectedPlayer) return;

        fetch('/api/duel/request', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                challengerId: currentPlayer.id,
                targetId: selectedPlayer.id
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`Duel request sent to ${selectedPlayer.username}`);
                } else {
                    alert(`Failed to send duel request: ${data.message}`);
                }
            })
            .catch(error => console.error('Error sending duel request:', error));
    }

    function handleDuelRequest(challengerId) {
        const challenger = players.find(p => p.id === challengerId);
        if (confirm(`${challenger.username} has challenged you to a duel. Do you accept?`)) {
            acceptDuelRequest(challengerId);
        } else {
            rejectDuelRequest(challengerId);
        }
    }

    function setupWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host;
        socket = new WebSocket(`${protocol}//${host}/ws`);

        socket.onopen = function(event) {
            console.log('WebSocket connection established');
            socket.send(JSON.stringify({ type: 'register', playerId: currentPlayer.id }));
        };

        socket.onmessage = function(event) {
            const data = JSON.parse(event.data);
            switch(data.type) {
                case 'duelRequest':
                    handleDuelRequest(data.challengerId);
                    break;
                case 'duelAccepted':
                    handleDuelAccepted(data.combatId, data.playerIds);
                    break;
                case 'playerMove':
                    updatePlayerPosition(data.playerId, data.x, data.y);
                    break;
                case 'duelRejected':
                    alert(`${data.targetUsername} has rejected your duel request.`);
                    break;
            }
        };

        socket.onclose = function(event) {
            console.log('WebSocket connection closed:', event);
            setTimeout(setupWebSocket, 5000);
        };

        socket.onerror = function(error) {
            console.error('WebSocket error:', error);
        };
    }

    function handleDuelAccepted(combatId, playerIds) {
        console.log('Duel accepted, starting combat:', combatId);
        currentCombatId = combatId;
        document.getElementById('worldMapContainer').style.display = 'none';
        document.getElementById('combatArea').style.display = 'block';

        // Fetch the initial combat state
        fetch(`/api/combat/${combatId}`)
            .then(response => response.json())
            .then(combat => {
                updateCombatUI(combat);
                fetchPlayerSpells();
                pollCombatStatus();
            })
            .catch(error => console.error('Error fetching initial combat state:', error));
    }

    function acceptDuelRequest(challengerId) {
        fetch('/api/duel/accept', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                challengerId: challengerId,
                targetId: currentPlayer.id
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Duel acceptance sent to server');
                    // The server will send a WebSocket message to both players to start the combat
                } else {
                    console.error('Failed to accept duel:', data.message);
                }
            })
            .catch(error => console.error('Error accepting duel request:', error));
    }

    function rejectDuelRequest(challengerId) {
        fetch('/api/duel/reject', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                challengerId: challengerId,
                targetId: currentPlayer.id
            })
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Duel request rejected');
                } else {
                    alert(`Failed to reject duel request: ${data.message}`);
                }
            })
            .catch(error => console.error('Error rejecting duel request:', error));
    }

    // WebSocket setup and handling

    // Event listeners
    canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        lastClickX = event.clientX - rect.left;
        lastClickY = event.clientY - rect.top;

        const worldX = currentPlayer.worldPositionX + Math.round(lastClickX - VIEWPORT_WIDTH / 2);
        const worldY = currentPlayer.worldPositionY + Math.round(lastClickY - VIEWPORT_HEIGHT / 2);

        updatePlayerPosition(currentPlayer, worldX, worldY);
    });

    // Debounce function

    // Update player position locally


    // Normalize vector to ensure diagonal movement isn't faster
    // Handle keydown events
    document.addEventListener('keydown', (event) => {
        let dx = 0, dy = 0;
        switch (event.key) {
            case 'ArrowUp':
            case 'w':
                dy = -MOVE_SPEED;
                break;
            case 'ArrowDown':
            case 's':
                dy = MOVE_SPEED;
                break;
            case 'ArrowLeft':
            case 'a':
                dx = -MOVE_SPEED;
                break;
            case 'ArrowRight':
            case 'd':
                dx = MOVE_SPEED;
                break;
        }
        if (dx !== 0 || dy !== 0) {
            updatePlayerPosition(currentPlayer.worldPositionX + dx, currentPlayer.worldPositionY + dy);
        }
    });

    // Handle keyup events
    document.addEventListener('keyup', (event) => {
        switch (event.key.toLowerCase()) {
            case 'w': case 's': movementVector.y = 0; break;
            case 'a': case 'd': movementVector.x = 0; break;
        }
        if (movementVector.x === 0 && movementVector.y === 0) {
            clearInterval(moveInterval);
            clearInterval(sendInterval);
            moveInterval = null;
            sendInterval = null;
            sendPositionToServer(); // Send final position
        }
    });

    // Modify the updatePlayerPosition function
    document.getElementById('chat-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            const message = this.value;
            if (message.trim() !== '') {
                // In a real implementation, you would send this message to your server
                addChatMessage(currentPlayer.username, message);
                this.value = '';
            }
        }
    });

    function addChatMessage(username, message) {
        const chatBox = document.getElementById('chat-box');
        const messageElement = document.createElement('p');
        messageElement.innerHTML = `<strong>${username}:</strong> ${message}`;
        chatBox.appendChild(messageElement);
        chatBox.scrollTop = chatBox.scrollHeight;
    }


        initWorldMap();
        setInterval(fetchPlayersInViewport, 5000); // Update every 5 seconds
</script>
</body>
</html>
